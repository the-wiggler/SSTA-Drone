figure;
hold on;
grid on;
view(3);
axis equal;
xlim([-10 10]); ylim([-10 10]); zlim([0 20]);
xlabel('X'); ylabel('Y'); zlabel('Z');

% set the initial position and rotation variables
pos_x = 0;
pos_y = 0;
pos_z = 0;
roll = 0;
pitch = 0;
yaw = 0;

drone_x_direction_initial = [1, 0, 0]; % pointing along the x axis
% defi motor positions relative to center (quadcopter X configuration)
motor_distance = 3; % distance from center to each motor
motor_positions_initial = [
    motor_distance/sqrt(2), motor_distance/sqrt(2), 0;    % FR motor
    -motor_distance/sqrt(2), motor_distance/sqrt(2), 0;   % FL motor
    -motor_distance/sqrt(2), -motor_distance/sqrt(2), 0;  % RL motor
    motor_distance/sqrt(2), -motor_distance/sqrt(2), 0    % RR motor
];

% create initial plot objects
drone_center = plot3(pos_x, pos_y, pos_z, 'ro', 'MarkerSize', 5, 'MarkerFaceColor', 'r');

% Create motor plot objects (blue circles)
motor1 = plot3(motor_positions_initial(1,1), motor_positions_initial(1,2), pos_z, 'bo', 'MarkerSize', 5, 'MarkerFaceColor', 'b');
motor2 = plot3(motor_positions_initial(2,1), motor_positions_initial(2,2), pos_z, 'bo', 'MarkerSize', 5, 'MarkerFaceColor', 'b');
motor3 = plot3(motor_positions_initial(3,1), motor_positions_initial(3,2), pos_z, 'bo', 'MarkerSize', 5, 'MarkerFaceColor', 'b');
motor4 = plot3(motor_positions_initial(4,1), motor_positions_initial(4,2), pos_z, 'bo', 'MarkerSize', 5, 'MarkerFaceColor', 'b');

arrow_length = 2;
front_arrow = quiver3(pos_x, pos_y, pos_z, arrow_length, 0, 0, 0, 'LineWidth', 2, 'Color', 'r', 'MaxHeadSize', 0.5);

iteration_counter = 0;
sim_running = true;

while sim_running == true
    % calculate quaternion from current Euler angles
    q_roll = quaternion(cos(roll / 2), sin(roll / 2), 0, 0);
    q_pitch = quaternion(cos(pitch / 2), 0, sin(pitch / 2), 0);
    q_yaw = quaternion(cos(yaw / 2), 0, 0, sin(yaw / 2));
    q_total = q_yaw * q_pitch * q_roll;
    
    % apply the rotation to direction vectors
    drone_front_direction = rotatepoint(q_total, drone_x_direction_initial);
    
    % apply the rotation to motor positions
    motor_positions_rotated = rotatepoint(q_total, motor_positions_initial);
    
    % update the center of mass
    set(drone_center, 'XData', pos_x, 'YData', pos_y, 'ZData', pos_z);
    
    % update motors with rotated positions
    set(motor1, 'XData', pos_x + motor_positions_rotated(1,1), 'YData', pos_y + motor_positions_rotated(1,2), 'ZData', pos_z + motor_positions_rotated(1,3));
    set(motor2, 'XData', pos_x + motor_positions_rotated(2,1), 'YData', pos_y + motor_positions_rotated(2,2), 'ZData', pos_z + motor_positions_rotated(2,3));
    set(motor3, 'XData', pos_x + motor_positions_rotated(3,1), 'YData', pos_y + motor_positions_rotated(3,2), 'ZData', pos_z + motor_positions_rotated(3,3));
    set(motor4, 'XData', pos_x + motor_positions_rotated(4,1), 'YData', pos_y + motor_positions_rotated(4,2), 'ZData', pos_z + motor_positions_rotated(4,3));
    
    % update arrows
    set(front_arrow, 'XData', pos_x, 'YData', pos_y, 'ZData', pos_z, 'UData', drone_front_direction(1)*arrow_length, 'VData', drone_front_direction(2)*arrow_length, 'WData', drone_front_direction(3)*arrow_length);
    
    drawnow;
    
    % increment the position and orientation
    pos_z = pos_z + 0.1;
    yaw = yaw + 0.01;
    pitch = pitch + 0.01;
    
    iteration_counter = iteration_counter + 1;
    if iteration_counter == 150
        sim_running = false;
    end
end
